// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: categories.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLeafCategoryIDsByRoot = `-- name: GetAllLeafCategoryIDsByRoot :many
WITH RECURSIVE subcategories (id, is_leaf) AS (
    SELECT
        c.id,
        c.is_leaf
    FROM categories c
    WHERE c.id = $1

    UNION ALL

    SELECT
        c.id,
        c.is_leaf
    FROM categories c
    INNER JOIN subcategories sc ON c.parent_id = sc.id
)
SELECT
    sc.id
FROM subcategories sc
WHERE sc.is_leaf = TRUE
`

func (q *Queries) GetAllLeafCategoryIDsByRoot(ctx context.Context, id uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getAllLeafCategoryIDsByRoot, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNonArchivedCategories = `-- name: GetAllNonArchivedCategories :many
SELECT
    id,
    parent_id,
    name,
    slug,
    level,
    is_leaf
FROM categories
WHERE is_archived = FALSE
ORDER BY level ASC, name ASC
`

type GetAllNonArchivedCategoriesRow struct {
	ID       uuid.UUID     `json:"id"`
	ParentID uuid.NullUUID `json:"parent_id"`
	Name     string        `json:"name"`
	Slug     string        `json:"slug"`
	Level    int32         `json:"level"`
	IsLeaf   bool          `json:"is_leaf"`
}

func (q *Queries) GetAllNonArchivedCategories(ctx context.Context) ([]GetAllNonArchivedCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllNonArchivedCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllNonArchivedCategoriesRow
	for rows.Next() {
		var i GetAllNonArchivedCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.Slug,
			&i.Level,
			&i.IsLeaf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT
  id,
  parent_id,
  name,
  slug,
  level,
  is_leaf,
  is_archived,
  created_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Slug,
		&i.Level,
		&i.IsLeaf,
		&i.IsArchived,
		&i.CreatedAt,
	)
	return i, err
}

const getProductVariantIndexesByCategoryIDs = `-- name: GetProductVariantIndexesByCategoryIDs :many
SELECT
    id, -- index id (not needed in response)

    -- Category
    categoryid,
    categoryname,
    iscategoryarchived,

    -- Seller
    sellerid,
    sellerstorename,
    issellerapproved,
    issellerarchived,
    issellerbanned,

    -- Product
    productid,
    producttitle,
    productdescription,
    productimages,
    productpromovideourl,
    isproductapproved,
    isproductarchived,
    isproductbanned,

    -- Variant
    variantid,
    color,
    size,
    isvariantinstock,
    stockamount,
    retailprice,
    retaildiscount,
    retaildiscounttype,
    has_retail_discount,
    haswholesaleenabled,
    wholesaleprice,
    wholesaleminquantity,
    wholesalediscount,
    wholesalediscounttype,
    isvariantarchived,
    weight_grams,

    -- Metadata
    views,
    createdat,
    updatedat

FROM product_variant_indexes
WHERE
    categoryid = ANY($1::uuid[])
    AND iscategoryarchived = FALSE
    AND isproductarchived = FALSE
    AND isproductapproved = TRUE
    AND isproductbanned = FALSE
    AND isvariantarchived = FALSE
    AND issellerarchived = FALSE
    AND issellerapproved = TRUE
    AND issellerbanned = FALSE
ORDER BY producttitle, variantid
`

type GetProductVariantIndexesByCategoryIDsRow struct {
	ID                    uuid.UUID      `json:"id"`
	Categoryid            uuid.UUID      `json:"categoryid"`
	Categoryname          string         `json:"categoryname"`
	Iscategoryarchived    bool           `json:"iscategoryarchived"`
	Sellerid              uuid.UUID      `json:"sellerid"`
	Sellerstorename       string         `json:"sellerstorename"`
	Issellerapproved      bool           `json:"issellerapproved"`
	Issellerarchived      bool           `json:"issellerarchived"`
	Issellerbanned        bool           `json:"issellerbanned"`
	Productid             uuid.UUID      `json:"productid"`
	Producttitle          string         `json:"producttitle"`
	Productdescription    string         `json:"productdescription"`
	Productimages         []string       `json:"productimages"`
	Productpromovideourl  sql.NullString `json:"productpromovideourl"`
	Isproductapproved     bool           `json:"isproductapproved"`
	Isproductarchived     bool           `json:"isproductarchived"`
	Isproductbanned       bool           `json:"isproductbanned"`
	Variantid             uuid.UUID      `json:"variantid"`
	Color                 string         `json:"color"`
	Size                  string         `json:"size"`
	Isvariantinstock      bool           `json:"isvariantinstock"`
	Stockamount           int32          `json:"stockamount"`
	Retailprice           int64          `json:"retailprice"`
	Retaildiscount        sql.NullInt64  `json:"retaildiscount"`
	Retaildiscounttype    sql.NullString `json:"retaildiscounttype"`
	HasRetailDiscount     bool           `json:"has_retail_discount"`
	Haswholesaleenabled   bool           `json:"haswholesaleenabled"`
	Wholesaleprice        sql.NullInt64  `json:"wholesaleprice"`
	Wholesaleminquantity  sql.NullInt32  `json:"wholesaleminquantity"`
	Wholesalediscount     sql.NullInt64  `json:"wholesalediscount"`
	Wholesalediscounttype sql.NullString `json:"wholesalediscounttype"`
	Isvariantarchived     bool           `json:"isvariantarchived"`
	WeightGrams           int32          `json:"weight_grams"`
	Views                 int64          `json:"views"`
	Createdat             time.Time      `json:"createdat"`
	Updatedat             time.Time      `json:"updatedat"`
}

func (q *Queries) GetProductVariantIndexesByCategoryIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]GetProductVariantIndexesByCategoryIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariantIndexesByCategoryIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantIndexesByCategoryIDsRow
	for rows.Next() {
		var i GetProductVariantIndexesByCategoryIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Categoryid,
			&i.Categoryname,
			&i.Iscategoryarchived,
			&i.Sellerid,
			&i.Sellerstorename,
			&i.Issellerapproved,
			&i.Issellerarchived,
			&i.Issellerbanned,
			&i.Productid,
			&i.Producttitle,
			&i.Productdescription,
			pq.Array(&i.Productimages),
			&i.Productpromovideourl,
			&i.Isproductapproved,
			&i.Isproductarchived,
			&i.Isproductbanned,
			&i.Variantid,
			&i.Color,
			&i.Size,
			&i.Isvariantinstock,
			&i.Stockamount,
			&i.Retailprice,
			&i.Retaildiscount,
			&i.Retaildiscounttype,
			&i.HasRetailDiscount,
			&i.Haswholesaleenabled,
			&i.Wholesaleprice,
			&i.Wholesaleminquantity,
			&i.Wholesalediscount,
			&i.Wholesalediscounttype,
			&i.Isvariantarchived,
			&i.WeightGrams,
			&i.Views,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
